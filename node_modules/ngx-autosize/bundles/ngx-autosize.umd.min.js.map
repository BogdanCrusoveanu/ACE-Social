{"version":3,"sources":["ng://ngx-autosize/lib/autosize.directive.ts","ng://ngx-autosize/lib/autosize.module.ts"],"names":["AutosizeDirective","element","_zone","this","onlyGrow","useImportant","resized","EventEmitter","retries","_destroyed","nativeElement","tagName","_findNestedTextArea","textAreaEl","style","overflow","_onTextAreaFound","Object","defineProperty","prototype","value","_minRows","rows","onInput","textArea","adjust","ngOnDestroy","_windowResizeHandler","window","removeEventListener","ngAfterContentChecked","ngOnChanges","changes","_this","querySelector","shadowRoot","console","warn","setTimeout","_addWindowResizeHandler","func","wait","immediate","timeout","context","args","arguments","later","apply","callNow","clearTimeout","Debounce","run","runOutsideAngular","addEventListener","inputsChanged","currentText","_oldContent","offsetWidth","_oldWidth","clone","cloneNode","parent_1","parentNode","width","visibility","position","textContent","appendChild","height","scrollHeight","computedStyle","getComputedStyle","parseInt","getPropertyValue","oldHeight","offsetHeight","willGrow","lineHeight","_getLineHeight","rowsCount","maxRows","maxHeight","Math","max","heightStyle","important","setProperty","emit","removeChild","isNaN","styles","fontSize","floor","replace","Directive","selector","ElementRef","NgZone","Input","Output","HostListener","AutosizeModule","NgModule","declarations","imports","exports"],"mappings":"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","sourcesContent":["import {\n    ElementRef,\n    HostListener,\n    Directive,\n    Input,\n    NgZone, OnDestroy, OnChanges, AfterContentChecked, Output, EventEmitter\n} from '@angular/core';\n\nconst MAX_LOOKUP_RETRIES = 3;\n\n@Directive({\n    selector: '[autosize]'\n})\n\nexport class AutosizeDirective implements OnDestroy, OnChanges, AfterContentChecked {\n    @Input()\n    set minRows(value) {\n        this._minRows = value;\n        if (this.textAreaEl) {\n            this.textAreaEl.rows = value;\n        }\n    };\n    private _minRows: number;\n\n    @Input() maxRows: number;\n    @Input() onlyGrow = false;\n    @Input() useImportant = false;\n\n    @Output() resized = new EventEmitter<number>();\n\n    private retries = 0;\n    private textAreaEl: any;\n\n    private _oldContent: string;\n    private _oldWidth: number;\n\n    private _windowResizeHandler;\n    private _destroyed = false;\n\n    @HostListener('input', ['$event.target'])\n    onInput(textArea: HTMLTextAreaElement): void {\n        this.adjust();\n    }\n\n    constructor(\n        public element: ElementRef,\n        private _zone: NgZone\n    ) {\n        if (this.element.nativeElement.tagName !== 'TEXTAREA') {\n            this._findNestedTextArea();\n\n        } else {\n            this.textAreaEl = this.element.nativeElement;\n            this.textAreaEl.style.overflow = 'hidden';\n            this._onTextAreaFound();\n        }\n    }\n\n    ngOnDestroy() {\n        this._destroyed = true;\n        if (this._windowResizeHandler) {\n            window.removeEventListener('resize', this._windowResizeHandler, false);\n        }\n    }\n\n    ngAfterContentChecked() {\n        this.adjust();\n    }\n\n    ngOnChanges(changes) {\n        this.adjust(true);\n    }\n\n    _findNestedTextArea() {\n        this.textAreaEl = this.element.nativeElement.querySelector('TEXTAREA');\n\n        if (!this.textAreaEl && this.element.nativeElement.shadowRoot) {\n            this.textAreaEl = this.element.nativeElement.shadowRoot.querySelector('TEXTAREA');\n        }\n\n        if (!this.textAreaEl) {\n            if (this.retries >= MAX_LOOKUP_RETRIES) {\n                console.warn('ngx-autosize: textarea not found');\n\n            } else {\n                this.retries++;\n                setTimeout(() => {\n                    this._findNestedTextArea();\n                }, 100);\n            }\n            return;\n        }\n\n        this.textAreaEl.style.overflow = 'hidden';\n        this._onTextAreaFound();\n\n    }\n\n    _onTextAreaFound() {\n        this._addWindowResizeHandler();\n        setTimeout(() => {\n            this.adjust();\n        });\n    }\n\n    _addWindowResizeHandler() {\n        this._windowResizeHandler = Debounce(() => {\n            this._zone.run(() => {\n                this.adjust();\n            });\n        }, 200);\n\n        this._zone.runOutsideAngular(() => {\n            window.addEventListener('resize', this._windowResizeHandler, false);\n        });\n    }\n\n    adjust(inputsChanged = false): void {\n        if (!this._destroyed && this.textAreaEl) {\n\n            const currentText = this.textAreaEl.value;\n\n            if (\n                inputsChanged === false &&\n                currentText === this._oldContent &&\n                this.textAreaEl.offsetWidth === this._oldWidth\n            ) {\n                return;\n            }\n\n            this._oldContent = currentText;\n            this._oldWidth = this.textAreaEl.offsetWidth;\n\n            const clone = this.textAreaEl.cloneNode(true);\n            const parent = this.textAreaEl.parentNode;\n            clone.style.width = this.textAreaEl.offsetWidth + 'px';\n            clone.style.visibility = 'hidden';\n            clone.style.position = 'absolute';\n            clone.textContent = currentText;\n\n            parent.appendChild(clone);\n\n            clone.style.overflow = 'hidden';\n            clone.style.height = 'auto';\n\n            let height = clone.scrollHeight;\n\n            // add into height top and bottom borders' width\n            let computedStyle = window.getComputedStyle(clone, null);\n            height += parseInt(computedStyle.getPropertyValue('border-top-width'));\n            height += parseInt(computedStyle.getPropertyValue('border-bottom-width'));\n\n            const oldHeight = this.textAreaEl.offsetHeight;\n            const willGrow = height > oldHeight;\n\n            if (this.onlyGrow === false || willGrow) {\n                const lineHeight = this._getLineHeight();\n                const rowsCount = height / lineHeight;\n\n                if (this._minRows && this._minRows >= rowsCount) {\n                    height = this._minRows * lineHeight;\n\n                } else if (this.maxRows && this.maxRows <= rowsCount) {\n                    // never shrink the textarea if onlyGrow is true\n                    const maxHeight = this.maxRows * lineHeight;\n                    height = this.onlyGrow ? Math.max(maxHeight, oldHeight): maxHeight;\n                    this.textAreaEl.style.overflow = 'auto';\n\n                } else {\n                    this.textAreaEl.style.overflow = 'hidden';\n                }\n\n                const heightStyle = height + 'px';\n                const important = this.useImportant ? 'important' : '';\n\n                this.textAreaEl.style.setProperty('height', heightStyle, important);\n\n                this.resized.emit(height);\n            }\n\n            parent.removeChild(clone);\n        }\n    }\n\n    private _getLineHeight() {\n        let lineHeight = parseInt(this.textAreaEl.style.lineHeight, 10);\n        if (isNaN(lineHeight) && window.getComputedStyle) {\n            const styles = window.getComputedStyle(this.textAreaEl);\n            lineHeight = parseInt(styles.lineHeight, 10);\n        }\n\n        if (isNaN(lineHeight)) {\n            const fontSize = window.getComputedStyle(this.textAreaEl, null).getPropertyValue('font-size');\n            lineHeight = Math.floor(parseInt(fontSize.replace('px', ''), 10) * 1.5);\n        }\n\n        return lineHeight;\n    }\n}\n\nfunction Debounce(func, wait, immediate = false) {\n    let timeout;\n    return function () {\n        const context = this;\n        const args = arguments;\n        const later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n        const callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n","import { NgModule } from '@angular/core';\nimport { AutosizeDirective } from './autosize.directive';\n\n@NgModule({\n  declarations: [AutosizeDirective],\n  imports: [\n  ],\n  exports: [AutosizeDirective]\n})\nexport class AutosizeModule { }\n"]}